/*
3. Сотрудники, подразделения -- отдел кадров

Подразделения в предприятии имеют иерархическую структуру.

Процессы:

найм, увольнение сотрудника
создание, переформирование, расформирование, перемещение, объединение подразделений
поиск сотрудника, определение структуры его подчиненности
переход сотрудников между подразделениями
работа сотрудника на несколько ставок в различных подразделениях
Необходимо реализовать функции сохранения и восстановления данных.

По каждому сотруднику должна вестись история его перемещений внутри компании в рамках сессии работы программы.
*/

#include "stdafx.h"
#include <iostream>
using namespace std;
class worker {
private : 
	char FIO;
	char position;
public: 
	worker(char name , char pos) {
		FIO = name;
		position = pos;
	}
	const char get_FIO() {
		return FIO;
	}
	const char get_position() {
		return position;
	}
	~worker() {}
};
struct element //Структура с инфополями и адресным полем
{
	char x; //Инфополе. значения из x будут передаваться в список
	element *Next; //Адресное поле
};

class List //Класс Список
{
	element *Head; //Указатель на последний активный элемент или просто голова списка
public:
	List() { Head = NULL; } //Конструктор и инициализация указателя пустым значением
	void Add(char x) //Функция добавления элементов в список
	{
		element *temp = new element; //При каждом вызове выделяется память
		temp->x = x; //Записываем x в элемент структуры  element (в x структуры element)
		temp->Next = Head; //Указываем, что след. элемент это объект по адресу Head
		Head = temp; //Указываем, что последний активный элемент это только что введенный
	}
	friend ostream& operator<<(ostream&, List&);
	void Show() //Функция отображения списка на экране
	{
		element *temp = Head; //Определяем указатель, который изначально он равен адресу начала списка
		while (temp != NULL) //До тех пор пока не встретит пустое значение
		{
			cout << temp->x << " "; //Выведет элемент x из списка
			temp = temp->Next; //Указываем, что далее нам нужен следующий элемент
		}
	}
	~List() 
	{
		while (Head != NULL)  //Пока по адресу не пусто 
		{
			element *temp = Head->Next; //Временная переменная для хранения адреса следующего элемента
			delete Head; //Освобождаем адрес обозначающий начало
			Head = temp; //Меняем адрес на следующий
		}
	}
};

class work : public worker {

};
int main()
{
	worker f('nik','boss');
	worker s('fed', 'ob');
	worker t('lena', 'exbo');
	worker fo('maza', 'lel');
	
    return 0;
}
